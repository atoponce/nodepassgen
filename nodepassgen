#!/usr/bin/env node

'use strict'

//globals
const FS = require('fs')
const OS = require('os')
const PATH = require('path')
const CRYPTO = require('crypto')
const ARGS = process.argv.slice(2)

/** Print usage. */
function printUsage() {
  console.log('Usage: nodepassgen [OPTION [ARG]]...')
  console.log('NOTE: A Unicode font may be needed to view some of the passwords correctly.')
  console.log('  -h, --help                 Print this help and exit.')
  console.log('  -a, --alternate WORDLIST   Choose an alternate wordlist. Default is Trump.')
  console.log('                               WORDLIST must be one of:')
  console.log('                                 Afrikaans, Belarusian, Colors, Common, Croatian,')
  console.log('                                 Deseret, Elvish, Everything, Klingon, Mongolian,')
  console.log('                                 PGP, Pokerware, Rockyou, Serbian, Shavian,')
  console.log('                                 Simpsons, S/KEY, Trump, Ukranian, Wordle.')
  console.log('                               NOTE: "English" combines every English word list.')
  console.log('  -b, --bitcoin LANGUAGE     Choose a Bitcoin language. Default is English.')
  console.log('                               LANGUAGE must be one of:')
  console.log('                                Chinese, Czech, English, French, Italian,')
  console.log('                                Japanese, Korean, Portuguese.')
  console.log('                               NOTE: Simplified Chinese is the default Chinese')
  console.log('                               character set. If you want to use Traditional')
  console.log('                               Chinese, use --traditional.')
  console.log('  -d, --diceware LANGUAGE    Choose a Diceware language. Default is English.')
  console.log('                               LANGUAGE must be one of:')
  console.log('                                 Basque, Beale, Bulgarian, Catalan, Chinese,')
  console.log('                                 Czech, Danish, Dutch, English, Esperanto,')
  console.log('                                 Estonian, Finnish, French, German, Greek,')
  console.log('                                 Hebrew, Hungarian, Italian, Japanese, Latin,')
  console.log('                                 Maori, NLP, Norwegian, Polish, Portuguese,')
  console.log('                                 Romanian, Russian, Slovak, Slovenian, Spanish,')
  console.log('                                 Swedish, Turkish.')
  console.log('                               NOTE: NLP is "Natural Language Passwords".')
  console.log('  -e, --eff WORDLIST         Choose an EFF wordlist. Default is Short.')
  console.log('                               WORDLIST must be one of:')
  console.log('                                 Distant, Long, Potter, Short, Thrones, Trek,')
  console.log('                                 Wars.')
  console.log('  -H, --hyphenate            Hyphenate Alternate, Bitcoin, Diceware, and EFF ')
  console.log('                               passphrases.')
  console.log('  -j, --json                 Output the passwords and meta in JSON format.')
  console.log('  -k, --keyboard             Collect random entropy from keyboard timings.')
  console.log('                               See -u, --use-entropy.')
  console.log('  -m, --min-entropy NUMBER   Set a minimum entropy in bits. Default is 70.')
  console.log('  -M, --monero LANGUAGE      Choose a Monero language. Default is English.')
  console.log('                               LANGUAGE must be one of:')
  console.log('                                Chinese, Dutch, English, Esperanto, French, German,')
  console.log('                                Italian, Japanese, Lojban, Portuguese, Russian,')
  console.log('                                Spanish.')
  console.log('  -o, --only GENERATOR       Choose a generator instead of printing all six.')
  console.log('                               GENERATOR must be one of:')
  console.log('                                 Alternate, Bitcoin, Diceware, EFF, Monero,')
  console.log('                                 Pseudowords, Random, System.')
  console.log('  -p, --pseudowords OPTION   Choose a Pseudowords option. Default is Apple.')
  console.log('                               OPTION must be one of:')
  console.log('                                 Apple, Babble, Daefen, Letterblock, Munemo,')
  console.log('                                 Proquints, Urbit.')
  console.log('  -r, --random SET           Choose from a string set. Default is Base94.')
  console.log('                               SET must be one of:')
  console.log('                                 Base256, Base220, Base188, Base94, Base85, Base64,')
  console.log('                                 Base62, Base58, Base52, Base45, Base36, Base32,')
  console.log('                                 Base26, Base16, Base10, Base8, Base4, Base2, Emoji.')
  console.log('  -s, --stats                Report collected keyboard entropy statistics.')
  console.log('                               A "sample" is 16 bits long and can be a word,')
  console.log('                               set, or character depending on the password type.')
  console.log('  -t, --traditional          Use Traditional Chinese with Bitcoin.')
  console.log('  -u, --use-entropy          Use previously saved entropy for generation.')
  console.log('                               Must be used with -o, --only.')
  console.log('                               See also -k, --keyboard.')
  process.exit()
}

/**
 * Get minimum entropy margin in bits from the user.
 * @returns {number} Entropy in bits.
 */
function getEntropy() {
  let entropy = 70

  if (ARGS.includes('-m') || ARGS.includes('--min-entropy')) {
    const option = ARGS.findIndex((option) => option === '-m' || option === '--min-entropy')
    entropy = ARGS[option + 1]
  }

  if (entropy < 48 || entropy === undefined) {
    console.log('Security value too low. Must be at least 48-bits.')
    process.exit(1)
  } else {
    return entropy
  }
}

/**
 * Set the location for the entropy file.
 * @returns {object} File containing entropy generated from the user.
 */
function setEntropyFile() {
  const homedir = process.platform === 'win32' ? process.env.HOMEPATH : process.env.HOME

  return PATH.join(homedir, 'nodepassgen.json')
}

/**
 * A cryptographically secure random number generator.
 * @param {number} count - The max number a random number can be.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {number} Uniform random number.
 */
function secRand(count, useEntropy) {
  let rand = 0
  let num = 0
  const min = 2 ** 16 % count
  const entropyFile = setEntropyFile()

  if (useEntropy) {
    try {
      const entropy = JSON.parse(FS.readFileSync(entropyFile, 'utf8'))

      if (entropy.length > 0) {
        num = entropy[0]
        entropy.shift()

        try {
          FS.writeFileSync(entropyFile, JSON.stringify(entropy))
        } catch (err) {
          console.error(err)
        }
      }
    } catch (err) {
      console.error(err)
    }
  }

  do {
    rand = CRYPTO.randomBytes(2)
    num ^= (rand[0] << 8 | rand[1])
  } while (num < min)

  return num % count
}

/**
 * Remove any and all duplicates from an array. Case sensitive.
 * @param {Array} list - An array of strings or numbers which might contain duplicates.
 * @returns {Array} The array with duplicates removed.
 */
function uniquesOnly(list) {
  // enforce unique elements in array
  return [...new Set(list)]
}

/**
 * The critical password generation function. Generates a password from a given set of data.
 * @param {number} len - How many characters/words to pick.
 * @param {string|Array} set - The data to pick from.
 * @param {boolean} spaces - Whether or not to include spaces in the password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {string} The generated password.
 */
function generatePass(len, set, spaces, useEntropy) {
  let pass = ''
  let passArr = ''

  if (typeof set === 'string') {
    passArr = set.split('')
  } else {
    passArr = set
  }

  for (let i = len; i--; ) {
    if (spaces) {
      pass += passArr[secRand(set.length, useEntropy)]
      pass += ' '
    } else {
      pass += passArr[secRand(set.length, useEntropy)]
    }
  }

  return pass.trim()
}

/**
 * Generate a Diceware passphrase based on the chosen language word list.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Object} An associative array of the generated passphrase and its meta.
 */
function generateDiceware(useEntropy) {
  let lang
  let wordlist = []

  if (ARGS.includes('-d') || ARGS.includes('--diceware')) {
    const option = ARGS.findIndex((option) => option === '-d' || option === '--diceware')
    lang = ARGS[option + 1]
  } else {
    lang = 'English'
  }

  if (lang.toLowerCase() === 'basque') {
    const dicewareBasque = require('./lists/dicewareBasque')
    wordlist = dicewareBasque.wordlist
    lang = 'Basque'
  } else if (lang.toLowerCase() === 'beale') {
    const dicewareBeale = require('./lists/dicewareBeale')
    wordlist = dicewareBeale.wordlist
    lang = 'Beale'
  } else if (lang.toLowerCase() === 'bulgarian') {
    const dicewareBulgarian = require('./lists/dicewareBulgarian')
    wordlist = dicewareBulgarian.wordlist
    lang = 'Bulgarian'
  } else if (lang.toLowerCase() === 'catalan') {
    const dicewareCatalan = require('./lists/dicewareCatalan')
    wordlist = dicewareCatalan.wordlist
    lang = 'Catalan'
  } else if (lang.toLowerCase() === 'chinese') {
    const dicewareChinese = require('./lists/dicewareChinese')
    wordlist = dicewareChinese.wordlist
    lang = 'Chinese'
  } else if (lang.toLowerCase() === 'czech') {
    const dicewareCzech = require('./lists/dicewareCzech')
    wordlist = dicewareCzech.wordlist
    lang = 'Czech'
  } else if (lang.toLowerCase() === 'danish') {
    const dicewareDanish = require('./lists/dicewareDanish')
    wordlist = dicewareDanish.wordlist
    lang = 'Danish'
  } else if (lang.toLowerCase() === 'dutch') {
    const dicewareDutch = require('./lists/dicewareDutch')
    wordlist = dicewareDutch.wordlist
    lang = 'Dutch'
  } else if (lang.toLowerCase() === 'english') {
    const dicewareEnglish = require('./lists/dicewareEnglish')
    wordlist = dicewareEnglish.wordlist
    lang = 'English'
  } else if (lang.toLowerCase() === 'esperanto') {
    const dicewareEsperanto = require('./lists/dicewareEsperanto')
    wordlist = dicewareEsperanto.wordlist
    lang = 'Esperanto'
  } else if (lang.toLowerCase() === 'estonian') {
    const dicewareEstonian = require('./lists/dicewareEstonian')
    wordlist = dicewareEstonian.wordlist
    lang = 'Estonian'
  } else if (lang.toLowerCase() === 'finnish') {
    const dicewareFinnish = require('./lists/dicewareFinnish')
    wordlist = dicewareFinnish.wordlist
    lang = 'Finnish'
  } else if (lang.toLowerCase() === 'french') {
    const dicewareFrench = require('./lists/dicewareFrench')
    wordlist = dicewareFrench.wordlist
    lang = 'French'
  } else if (lang.toLowerCase() === 'german') {
    const dicewareGerman = require('./lists/dicewareGerman')
    wordlist = dicewareGerman.wordlist
    lang = 'German'
  } else if (lang.toLowerCase() === 'greek') {
    const dicewareGreek = require('./lists/dicewareGreek')
    wordlist = dicewareGreek.wordlist
    lang = 'Greek'
  } else if (lang.toLowerCase() === 'hebrew') {
    const dicewareHebrew = require('./lists/dicewareHebrew')
    wordlist = dicewareHebrew.wordlist
    lang = 'Hebrew'
  } else if (lang.toLowerCase() === 'hungarian') {
    const dicewareHungarian = require('./lists/dicewareHungarian')
    wordlist = dicewareHungarian.wordlist
    lang = 'Hungarian'
  } else if (lang.toLowerCase() === 'italian') {
    const dicewareItalian = require('./lists/dicewareItalian')
    wordlist = dicewareItalian.wordlist
    lang = 'Italian'
  } else if (lang.toLowerCase() === 'japanese') {
    const dicewareJapanese = require('./lists/dicewareJapanese')
    wordlist = dicewareJapanese.wordlist
    lang = 'Japanese'
  } else if (lang.toLowerCase() === 'latin') {
    const dicewareLatin = require('./lists/dicewareLatin')
    wordlist = dicewareLatin.wordlist
    lang = 'Latin'
  } else if (lang.toLowerCase() === 'maori') {
    const dicewareMaori = require('./lists/dicewareMaori')
    wordlist = dicewareMaori.wordlist
    lang = 'Maori'
  } else if (lang.toLowerCase() === 'nlp') {
    const dicewareNLP = require('./lists/dicewareNLP')
    wordlist = dicewareNLP.wordlist
    lang = 'NLP'
  } else if (lang.toLowerCase() === 'norwegian') {
    const dicewareNorwegian = require('./lists/dicewareNorwegian')
    wordlist = dicewareNorwegian.wordlist
    lang = 'Norwegian'
  } else if (lang.toLowerCase() === 'polish') {
    const dicewarePolish = require('./lists/dicewarePolish')
    wordlist = dicewarePolish.wordlist
    lang = 'Polish'
  } else if (lang.toLowerCase() === 'portuguese') {
    const dicewarePortuguese = require('./lists/dicewarePortuguese')
    wordlist = dicewarePortuguese.wordlist
    lang = 'Portuguese'
  } else if (lang.toLowerCase() === 'romanian') {
    const dicewareRomanian = require('./lists/dicewareRomanian')
    wordlist = dicewareRomanian.wordlist
    lang = 'Romanian'
  } else if (lang.toLowerCase() === 'russian') {
    const dicewareRussian = require('./lists/dicewareRussian')
    wordlist = dicewareRussian.wordlist
    lang = 'Russian'
  } else if (lang.toLowerCase() === 'slovak') {
    const dicewareSlovak = require('./lists/dicewareSlovak')
    wordlist = dicewareSlovak.wordlist
    lang = 'Slovak'
  } else if (lang.toLowerCase() === 'slovenian') {
    const dicewareSlovenian = require('./lists/dicewareSlovenian')
    wordlist = dicewareSlovenian.wordlist
    lang = 'Slovenian'
  } else if (lang.toLowerCase() === 'spanish') {
    const dicewareSpanish = require('./lists/dicewareSpanish')
    wordlist = dicewareSpanish.wordlist
    lang = 'Spanish'
  } else if (lang.toLowerCase() === 'swedish') {
    const dicewareSwedish = require('./lists/dicewareSwedish')
    wordlist = dicewareSwedish.wordlist
    lang = 'Swedish'
  } else if (lang.toLowerCase() === 'turkish') {
    const dicewareTurkish = require('./lists/dicewareTurkish')
    wordlist = dicewareTurkish.wordlist
    lang = 'Turkish'
  } else {
    console.log('Unknown language:', lang)
    process.exit(1)
  }

  wordlist = uniquesOnly(wordlist)

  const assocArr = {}
  const entropy = getEntropy()
  let pass = ''
  let len = 0

  if (wordlist.filter(Array.isArray).length === 2) {
    // We're working on the 'Natural Language Passwords' list
    const len1 = Math.ceil(entropy / Math.log2(wordlist[0].length)) // adjectives
    const len2 = Math.ceil(entropy / Math.log2(wordlist[1].length)) // nouns

    const adjs = generatePass(len1, wordlist[0], true, useEntropy).split(' ')
    const nouns = generatePass(len2, wordlist[1], true, useEntropy).split(' ')

    let bits = 0
    let counter = 0

    len = len1 + len2

    while (bits <= entropy) {
      // building up the password alternating: adj-noun-adj-noun-...
      if (counter % 2 === 0) {
        pass += adjs[counter]
        bits += Math.log2(wordlist[0].length)
      } else {
        pass += nouns[counter]
        bits += Math.log2(wordlist[1].length)
      }

      pass += ' '
      counter++
    }

    pass = pass.trim()
  } else {
    // Every other Diceware word list.
    len = Math.ceil(entropy / Math.log2(wordlist.length))
    pass = generatePass(len, wordlist, true, useEntropy)
  }

  if (ARGS.includes('-H') || ARGS.includes('--hyphenate')) {
    pass = pass.split(' ').join('-')
  }

  assocArr.Generator = 'Diceware'
  assocArr.Wordlist = lang
  assocArr.Password = pass
  assocArr.Characters = pass.replace(/\s/g, '').length
  assocArr.Entropy = Math.floor(len * Math.log2(wordlist.length))

  return assocArr
}

/**
 * Generate an EFF passphrase based on the chosen word list.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Object} An associative array of the generated passphrase and its meta.
 */
function generateEff(useEntropy) {
  let effSet
  let wordlist = []

  if (ARGS.includes('-e') || ARGS.includes('--eff')) {
    const option = ARGS.findIndex((option) => option === '-e' || option === '--eff')
    effSet = ARGS[option + 1]
  } else {
    effSet = 'Short'
  }

  if (effSet.toLowerCase() === 'distant') {
    const effDistant = require('./lists/effDistant')
    wordlist = effDistant.wordlist
    effSet = 'Distant'
  } else if (effSet.toLowerCase() === 'long') {
    const effLong = require('./lists/effLong')
    wordlist = effLong.wordlist
    effSet = 'Long'
  } else if (effSet.toLowerCase() === 'potter') {
    const effHarryPotter = require('./lists/effHarryPotter')
    wordlist = effHarryPotter.wordlist
    effSet = 'Harry Potter'
  } else if (effSet.toLowerCase() === 'short') {
    const effShort = require('./lists/effShort')
    wordlist = effShort.wordlist
    effSet = 'Short'
  } else if (effSet.toLowerCase() === 'thrones') {
    const effGameOfThrones = require('./lists/effGameOfThrones')
    wordlist = effGameOfThrones.wordlist
    effSet = 'Game of Thrones'
  } else if (effSet.toLowerCase() === 'trek') {
    const effStarTrek = require('./lists/effStarTrek')
    wordlist = effStarTrek.wordlist
    effSet = 'Star Trek'
  } else if (effSet.toLowerCase() === 'wars') {
    const effStarWars = require('./lists/effStarWars')
    wordlist = effStarWars.wordlist
    effSet = 'Star Wars'
  } else {
    console.log('Unknown wordlist:', effSet)
    process.exit()
  }

  wordlist = uniquesOnly(wordlist)

  const assocArr = {}
  const entropy = getEntropy()
  const len = Math.ceil(entropy / Math.log2(wordlist.length))
  let pass = generatePass(len, wordlist, true, useEntropy)

  if (ARGS.includes('-H') || ARGS.includes('--hyphenate')) {
    pass = pass.split(' ').join('-')
  }

  assocArr.Generator = 'EFF'
  assocArr.Wordlist = effSet
  assocArr.Password = pass
  assocArr.Characters = pass.replace(/\s/g, '').length
  assocArr.Entropy = Math.floor(len * Math.log2(wordlist.length))

  return assocArr
}

/**
 * Generate an Alternate passphrase based on the chosen word list.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Object} An associative array of the generated passphrase and its meta.
 */
function generateAlternate(useEntropy) {
  let altSet
  let wordlist = []

  if (ARGS.includes('-a') || ARGS.includes('--alternate')) {
    const option = ARGS.findIndex((option) => option === '-a' || option === '--alternate')
    altSet = ARGS[option + 1]
  } else {
    altSet = 'Trump'
  }

  if (altSet.toLowerCase() === 'afrikaans') {
    const alternateAfrikaans = require('./lists/alternateAfrikaans')
    wordlist = alternateAfrikaans.wordlist
    altSet = 'Afrikaans'
  } else if (altSet.toLowerCase() === 'belarusian') {
    const alternateBelarusian = require('./lists/alternateBelarusian')
    wordlist = alternateBelarusian.wordlist
    altSet = 'Belarusian'
  } else if (altSet.toLowerCase() === 'colors') {
    const alternateColors = require('./lists/alternateColors')
    wordlist = alternateColors.wordlist
    altSet = 'Colors'
  } else if (altSet.toLowerCase() === 'croatian') {
    const alternateCroatian = require('./lists/alternateCroatian')
    wordlist = alternateCroatian.wordlist
    altSet = 'Croatian'
  } else if (altSet.toLowerCase() === 'deseret') {
    const alternateDeseret = require('./lists/alternateDeseret')
    wordlist = alternateDeseret.wordlist
    altSet = 'Deseret'
  } else if (altSet.toLowerCase() === 'elvish') {
    const alternateElvish = require('./lists/alternateElvish')
    wordlist = alternateElvish.wordlist
    altSet = 'Elvish'
  } else if (altSet.toLowerCase() === 'everything') {
    const alternateColors = require('./lists/alternateColors')
    const alternatePgp = require('./lists/alternatePgp')
    const alternatePokerware = require('./lists/alternatePokerware')
    const alternateRockyou = require('./lists/alternateRockyou')
    const alternateSimpsons = require('./lists/alternateSimpsons')
    const alternateSkey = require('./lists/alternateSkey')
    const alternateTrump = require('./lists/alternateTrump')
    const alternateWordle = require('./lists/alternateWordle')
    const bitcoinEnglish = require('./lists/bitcoinEN')
    const dicewareBeale = require('./lists/dicewareBeale')
    const dicewareEnglish = require('./lists/dicewareEnglish')
    const dicewareNLP = require('./lists/dicewareNLP')
    const effDistant = require('./lists/effDistant')
    const effLong = require('./lists/effLong')
    const effHarryPotter = require('./lists/effHarryPotter')
    const effShort = require('./lists/effShort')
    const effGameOfThrones = require('./lists/effGameOfThrones')
    const effStarTrek = require('./lists/effStarTrek')
    const effStarWars = require('./lists/effStarWars')
    wordlist = alternateColors.wordlist                     // 1029 words
    wordlist = wordlist.concat(alternatePgp.wordlist)       //  512 words
    wordlist = wordlist.concat(alternatePokerware.wordlist) // 5304 words
    wordlist = wordlist.concat(alternateRockyou.wordlist)   // 7776 words
    wordlist = wordlist.concat(alternateSimpsons.wordlist)  // 5000 words
    wordlist = wordlist.concat(alternateSkey.wordlist)      // 2048 words
    wordlist = wordlist.concat(alternateTrump.wordlist)     // 8192 words
    wordlist = wordlist.concat(alternateWordle.wordlist)    // 5790 words
    wordlist = wordlist.concat(bitcoinEnglish.wordlist)     // 2048 words
    wordlist = wordlist.concat(dicewareEnglish.wordlist)    // 8192 words
    wordlist = wordlist.concat(dicewareBeale.wordlist)      // 7776 words
    wordlist = wordlist.concat(dicewareNLP.wordlist[0])     // 1296 words
    wordlist = wordlist.concat(dicewareNLP.wordlist[1])     // 7776 words
    wordlist = wordlist.concat(effDistant.wordlist)         // 1296 words
    wordlist = wordlist.concat(effGameOfThrones.wordlist)   // 4000 words
    wordlist = wordlist.concat(effHarryPotter.wordlist)     // 4000 words
    wordlist = wordlist.concat(effLong.wordlist)            // 4000 words
    wordlist = wordlist.concat(effShort.wordlist)           // 1296 words
    wordlist = wordlist.concat(effStarTrek.wordlist)        // 4000 words
    wordlist = wordlist.concat(effStarWars.wordlist)        // 4000 words
    altSet = 'Every Word List'
  } else if (altSet.toLowerCase() === 'common') {
    const alternatePgp = require('./lists/alternatePgp')
    const alternatePokerware = require('./lists/alternatePokerware')
    const alternateWordle = require('./lists/alternateWordle')
    const bitcoinEnglish = require('./lists/bitcoinEN')
    const dicewareNLP = require('./lists/dicewareNLP')
    const effDistant = require('./lists/effDistant')
    const effLong = require('./lists/effLong')
    const effShort = require('./lists/effShort')
    wordlist = alternatePgp.wordlist                        //  512 words
    wordlist = wordlist.concat(alternatePokerware.wordlist) // 5304 words
    wordlist = wordlist.concat(alternateWordle.wordlist)    // 5790 words
    wordlist = wordlist.concat(bitcoinEnglish.wordlist)     // 2048 words
    wordlist = wordlist.concat(dicewareNLP.wordlist[0])     // 1296 words
    wordlist = wordlist.concat(dicewareNLP.wordlist[1])     // 7776 words
    wordlist = wordlist.concat(effDistant.wordlist)         // 1296 words
    wordlist = wordlist.concat(effLong.wordlist)            // 4000 words
    wordlist = wordlist.concat(effShort.wordlist)           // 1296 words
    altSet = 'Common Words Only'
  } else if (altSet.toLowerCase() === 'klingon') {
    const alternateKlingon = require('./lists/alternateKlingon')
    wordlist = alternateKlingon.wordlist
    altSet = 'Klingon'
  } else if (altSet.toLowerCase() === 'mongolian') {
    const alternateMongolian = require('./lists/alternateMongolian')
    wordlist = alternateMongolian.wordlist
    altSet = 'Mongolian'
  } else if (altSet.toLowerCase() === 'pgp') {
    const alternatePgp = require('./lists/alternatePgp')
    wordlist = alternatePgp.wordlist
    altSet = 'PGP'
  } else if (altSet.toLowerCase() === 'pokerware') {
    const alternatePokerware = require('./lists/alternatePokerware')
    wordlist = alternatePokerware.wordlist
    altSet = 'Pokerware'
  } else if (altSet.toLowerCase() === 'rockyou') {
    const alternateRockyou = require('./lists/alternateRockyou')
    wordlist = alternateRockyou.wordlist
    altSet = 'RockYou'
  } else if (altSet.toLowerCase() === 'serbian') {
    const alternateSerbian = require('./lists/alternateSerbian')
    wordlist = alternateSerbian.wordlist
    altSet = 'Serbian'
  } else if (altSet.toLowerCase() === 'shavian') {
    const alternateShavian = require('./lists/alternateShavian')
    wordlist = alternateShavian.wordlist
    altSet = 'Shavian'
  } else if (altSet.toLowerCase() === 'simpsons') {
    const alternateSimpsons = require('./lists/alternateSimpsons')
    wordlist = alternateSimpsons.wordlist
    altSet = 'Simpsons'
  } else if (altSet.toLowerCase() === 's/key') {
    const alternateSkey = require('./lists/alternateSkey')
    wordlist = alternateSkey.wordlist
    altSet = 'S/KEY'
  } else if (altSet.toLowerCase() === 'trump') {
    const alternateTrump = require('./lists/alternateTrump')
    wordlist = alternateTrump.wordlist
    altSet = 'Trump'
  } else if (altSet.toLowerCase() === 'ukranian') {
    const alternateUkranian = require('./lists/alternateUkranian')
    wordlist = alternateUkranian.wordlist
    altSet = 'Ukranian'
  } else if (altSet.toLowerCase() === 'wordle') {
    const alternateWordle = require('./lists/alternateWordle')
    wordlist = alternateWordle.wordlist
    altSet = 'Wordle'
  } else {
    console.log('Unknown wordlist:', altSet)
    process.exit(1)
  }

  wordlist = uniquesOnly(wordlist)

  const assocArr = {}
  const entropy = getEntropy()
  const len = Math.ceil(entropy / Math.log2(wordlist.length))
  let pass = generatePass(len, wordlist, true, useEntropy)

  if (ARGS.includes('-H') || ARGS.includes('--hyphenate')) {
    pass = pass.split(' ').join('-')
  }

  assocArr.Generator = 'Alternate'
  assocArr.Wordlist = altSet
  assocArr.Password = pass
  assocArr.Characters = pass.replace(/\s/g, '').length
  assocArr.Entropy = Math.floor(len * Math.log2(wordlist.length))

  return assocArr
}

/**
 * Generate a Monero-compliant passphrase (seed). Contains checksum.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Object} An associative array of the generated passphrase and its meta.
 */
function generateMonero(useEntropy) {
  /**
   * Calculate the CRC32 of a string.
   * @param {string} string - The string to calculate.
   * @returns {number} A 32-bit integer.
   */
  var crc32 = function (str) {
    // https://gist.github.com/lenqwang/1be7b4843a580f2c1df84d5360e5e88c
    let crc = 0 ^ -1
    const crcTable = []

    for (let i = 0; i < 256; i++) {
      let c = i

      for (let j = 0; j < 8; j++) {
        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1
      }

      crcTable[i] = c
    }

    for (let i = 0; i < str.length; i++) {
      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xff]
    }

    return (crc ^ -1) >>> 0
  }

  let lang
  let pass = ''
  let wordlist = []

  if (ARGS.includes('-M') || ARGS.includes('--monero')) {
    const option = ARGS.findIndex((option) => option === '-M' || option === '--monero')
    lang = ARGS[option + 1]
  } else {
    lang = 'English'
  }

  if (lang.toLowerCase() === 'chinese') {
    const moneroCN = require('./lists/moneroCN')
    wordlist = moneroCN.wordlist
    lang = 'Chinese'
  } else if (lang.toLowerCase() === 'dutch') {
    const dutchWordlist = require('./lists/moneroNL')
    wordlist = dutchWordlist.wordlist
    lang = 'Czech'
  } else if (lang.toLowerCase() === 'english') {
    const englishWordlist = require('./lists/moneroEN')
    wordlist = englishWordlist.wordlist
    lang = 'English'
  } else if (lang.toLowerCase() === 'esperanto') {
    const esperantoWordlist = require('./lists/moneroEO')
    wordlist = esperantoWordlist.wordlist
    lang = 'Esperanto'
  } else if (lang.toLowerCase() === 'french') {
    const frenchWordlist = require('./lists/moneroFR')
    wordlist = frenchWordlist.wordlist
    lang = 'French'
  } else if (lang.toLowerCase() === 'german') {
    const germanWordlist = require('./lists/moneroDE')
    wordlist = germanWordlist.wordlist
    lang = 'German'
  } else if (lang.toLowerCase() === 'italian') {
    const italianWordlist = require('./lists/moneroIT')
    wordlist = italianWordlist.wordlist
    lang = 'Italian'
  } else if (lang.toLowerCase() === 'japanese') {
    const japaneseWordlist = require('./lists/moneroJP')
    wordlist = japaneseWordlist.wordlist
    lang = 'Japanese'
  } else if (lang.toLowerCase() === 'lojban') {
    const lojbanWordlist = require('./lists/moneroJBO')
    wordlist = lojbanWordlist.wordlist
    lang = 'Lojban'
  } else if (lang.toLowerCase() === 'portuguese') {
    const portugueseWordlist = require('./lists/moneroPT')
    wordlist = portugueseWordlist.wordlist
    lang = 'Portuguese'
  } else if (lang.toLowerCase() === 'russian') {
    const russianWordlist = require('./lists/moneroRU')
    wordlist = russianWordlist.wordlist
    lang = 'Russian'
  } else if (lang.toLowerCase() === 'spanish') {
    const spanishWordlist = require('./lists/moneroES')
    wordlist = spanishWordlist.wordlist
    lang = 'Spanish'
  } else {
    console.log('Unknown language:', lang)
    process.exit(1)
  }

  wordlist = uniquesOnly(wordlist)  // Force unique elements in array.

  const assocArr = {}
  const entropy = Math.ceil(getEntropy() / 32) * 32 // Multiple of 32 bits
  const len = Math.ceil(entropy / Math.log2(wordlist.length))

  pass = generatePass(len, wordlist, true, useEntropy).split(' ')

  let prefixes = ''

  for (let i = 0; i < pass.length; i++) {
    prefixes += pass[i].substring(0, 3)
  }

  const checksum = crc32(prefixes)
  const checkWord = pass[checksum % pass.length]

  pass.push(checkWord)
  pass = pass.join(' ')

  if (ARGS.includes('-H') || ARGS.includes('--hyphenate')) {
    pass = pass.split(' ').join('-')
  }

  assocArr.Generator = 'Monero'
  assocArr.Wordlist = lang
  assocArr.Password = pass
  assocArr.Characters = pass.replace(/\s/g, '').length
  assocArr.Entropy = entropy
  assocArr.Checksum = true

  return assocArr
}

/**
 * Generate a Bitcoin BIPS39-compliante passphrase (seed). Contains checksum.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Object} An associative array of the generated passphrase and its meta.
 */
function generateBitcoin(useEntropy) {
  let lang
  let pass = ''
  let wordlist = []

  if (ARGS.includes('-b') || ARGS.includes('--bitcoin')) {
    const option = ARGS.findIndex((option) => option === '-b' || option === '--bitcoin')
    lang = ARGS[option + 1]
  } else {
    lang = 'English'
  }

  if (lang.toLowerCase() === 'chinese') {
    if (ARGS.includes('-t') || ARGS.includes('--traditional')) {
      const bitcoinCNTrad = require('./lists/bitcoinCNTrad')
      wordlist = bitcoinCNTrad.wordlist
      lang = 'Chinese (Trad)'
    } else {
      const bitcoinCNSimp = require('./lists/bitcoinCNSimp')
      wordlist = bitcoinCNSimp.wordlist
      lang = 'Chinese (Simp)'
    }
  } else if (lang.toLowerCase() === 'czech') {
    const czechWordlist = require('./lists/bitcoinCZ')
    wordlist = czechWordlist.wordlist
    lang = 'Czech'
  } else if (lang.toLowerCase() === 'english') {
    const englishWordlist = require('./lists/bitcoinEN')
    wordlist = englishWordlist.wordlist
    lang = 'English'
  } else if (lang.toLowerCase() === 'french') {
    const frenchWordlist = require('./lists/bitcoinFR')
    wordlist = frenchWordlist.wordlist
    lang = 'French'
  } else if (lang.toLowerCase() === 'italian') {
    const italianWordlist = require('./lists/bitcoinIT')
    wordlist = italianWordlist.wordlist
    lang = 'Italian'
  } else if (lang.toLowerCase() === 'japanese') {
    const japaneseWordlist = require('./lists/bitcoinJP')
    wordlist = japaneseWordlist.wordlist
    lang = 'Japanese'
  } else if (lang.toLowerCase() === 'korean') {
    const koreanWordlist = require('./lists/bitcoinKR')
    wordlist = koreanWordlist.wordlist
    lang = 'Korean'
  } else if (lang.toLowerCase() === 'portuguese') {
    const portugueseWordlist = require('./lists/bitcoinPT')
    wordlist = portugueseWordlist.wordlist
    lang = 'Portuguese'
  } else if (lang.toLowerCase() === 'spanish') {
    const spanishWordlist = require('./lists/bitcoinES')
    wordlist = spanishWordlist.wordlist
    lang = 'Spanish'
  } else {
    console.log('Unknown language:', lang)
    process.exit(1)
  }

  wordlist = uniquesOnly(wordlist)

  var bytesToBinary = function (bytes) {
    let total = BigInt(0)

    for (let i = 0; i < bytes.length; i++) {
      total |= BigInt(bytes[i] * 256 ** (bytes.length - i - 1))
    }

    return total.toString(2)
  }

  const assocArr = {}
  const entropy = getEntropy()
  const requiredEntropy = Math.ceil(entropy / 32) * 32 // Multiple of 32 bits, per the bip39 spec
  const entropyBuffer = new Uint8Array(Math.ceil(requiredEntropy / 8))

  for (let i = 0; i < entropyBuffer.length; i++) {
    entropyBuffer[i] = secRand(256, useEntropy)
  }

  const digest = CRYPTO.createHash('sha256').update(entropyBuffer).digest()
  const entropyBits = bytesToBinary(entropyBuffer).padStart(requiredEntropy, '0')
  const checkBits = bytesToBinary(digest)
    .padStart(256, '0')
    .substr(0, 11 - (requiredEntropy % 11))
  const allBits = entropyBits + checkBits

  const bitWords = allBits.match(/(.{1,11})/g)
  const words = bitWords.map(function (binary) {
    return wordlist[parseInt(binary, 2)]
  })

  pass = words.join(' ')

  const len = Math.ceil(entropy / Math.log2(wordlist.length))

  if (ARGS.includes('-H') || ARGS.includes('--hyphenate')) {
    pass = pass.split(' ').join('-')
  }

  assocArr.Generator = 'Bitcoin'
  assocArr.Wordlist = lang
  assocArr.Password = pass
  assocArr.Characters = pass.replace(/\s/g, '').length
  assocArr.Entropy = requiredEntropy
  assocArr.Checksum = true

  return assocArr
}

/**
 * Generate a Keychain formatted password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateApple(useEntropy) {
  /**
   * Calculate the entropy of an Apple password containing n-blocks.
   * @param {number} n - The number of blocks in the password.
   * @returns {number} Entropy in bits.
   */
  var apple = function (n) {
    /*
      See the Twitter thread at https://twitter.com/AaronToponce/status/1131406726069084160
      for full analysis.

      For n â‰¥ 1 blocks, the entropy in bits per block is:
         log2(
           (6n-1) *    //  One lowercase alphabetic character is randomly capitalized
           19^(4n-1) * //  The total possible combinations of consonants
           6^(2n) *    //  The total possible combinations of vowels
           10 * 2n     //  An 'edge' character is a random digit
         )

      E.G.:
        DVccvc:                      log2( 5 * 19^3  * 6^2 * 10 * 2) ~=  24.558 bits
        cvCcvD-cvccvc:               log2(11 * 19^7  * 6^4 * 10 * 4) ~=  48.857 bits
        cvcCvc-Dvccvc-cvccvc:        log2(17 * 19^11 * 6^6 * 10 * 6) ~=  72.231 bits
        cvccVc-cvccvD-cvccvc-cvccvc: log2(23 * 19^15 * 6^8 * 10 * 8) ~=  95.244 bits
        et cetera, et cetera, et cetera.
    */
    return Math.floor(Math.log2((6 * n - 1) * 19 ** (4 * n - 1) * 6 ** (2 * n) * 20 * n))
  }

  const pass = []
  const digits = '0123456789'
  const vowels = 'aeiouy'
  const consonants = 'bcdfghjkmnpqrstvwxz'
  const entropy = getEntropy()

  let n = 1 // number of blocks

  while (apple(n) < entropy) {
    n++
  }

  for (let i = 0; i < n; i++) {
    pass[6 * i] = generatePass(1, consonants, false, useEntropy)
    pass[6 * i + 1] = generatePass(1, vowels, false, useEntropy)
    pass[6 * i + 2] = generatePass(1, consonants, false, useEntropy)
    pass[6 * i + 3] = generatePass(1, consonants, false, useEntropy)
    pass[6 * i + 4] = generatePass(1, vowels, false, useEntropy)
    pass[6 * i + 5] = generatePass(1, consonants, false, useEntropy)
  }

  let dLoc = 0
  let cLoc = 0
  const edge = secRand(2 * n, useEntropy) // [0, 2n)
  const digit = generatePass(1, digits, false, useEntropy)

  if (edge % 2 === 0) {
    dLoc = 3 * edge
  } else {
    dLoc = 3 * edge + 2
  }

  pass[dLoc] = digit

  do {
    cLoc = secRand(pass.length, useEntropy)
  } while (cLoc === dLoc)

  pass[cLoc] = pass[cLoc].toUpperCase()

  for (let i = n - 1; i > 0; i--) {
    pass.splice(6 * i, 0, '-')
  }

  return [pass.join(''), pass.length, apple(n)]
}

/**
 * Generate a Letterblock password. Contains cehcksum.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateLetterblock(useEntropy) {
  // https://www.draketo.de/software/letterblock-diceware
  // Diverged from above with:
  //  - '$' and '%' appended to make the checksum delimiters 6 characters
  //  - Treating digits as leet-speak
  /**
   * Determines if the string is a digit.
   * @param {string} str - The string to check.
   * @returns True if the string is a digit, false otherwise.
   */
  var isDigit = function (str) {
    return str.length === 1 && str.match(/[0-9]/)
  }

  /**
   * Replace a string with a leet-speak version.
   * @param {string} str - A stringified number.
   * @returns A leet-speak version of the number.
   */
  var replaceDigit = function (str) {
    if (str === '0') {
      return 'o'
    } else if (str === '1') {
      return 'l'
    } else if (str === '2') {
      return 'z'
    } else if (str === '3') {
      return 'e'
    } else if (str === '4') {
      return 'a'
    } else if (str === '5') {
      return 's'
    } else if (str === '6') {
      return 'b'
    } else if (str === '7') {
      return 't'
    } else if (str === '8') {
      return 'b'
    } else if (str === '9') {
      return 'g'
    }
  }

  /**
   * A recursive function to build a cross-product array of strings based on the contents of "arr".
   * @param {Array} arr - An array of four random strings from the "letters" multi-dimensional array.
   * @param {Array} res - The cross-product of the elements on "arr".
   * @param {number} ctr - A counter to keep track of the number of digits in the string.
   */
  var getCombos = function (arr, res, ctr) {
    const ptr0 = ctr.toString(2).padStart(4, '0')[0]  // most significant bit in bin(ctr)
    const ptr1 = ctr.toString(2).padStart(4, '0')[1]
    const ptr2 = ctr.toString(2).padStart(4, '0')[2]
    const ptr3 = ctr.toString(2).padStart(4, '0')[3]  // least significant bit in bin(ctr)

    if (
      arr[0][ptr0] !== undefined &&
      arr[1][ptr1] !== undefined &&
      arr[2][ptr2] !== undefined &&
      arr[3][ptr3] !== undefined
    ) {
      res.push(arr[0][ptr0] + arr[1][ptr1] + arr[2][ptr2] + arr[3][ptr3]) // the cross-product of "arr"
    }

    ctr++

    if (ctr < 16) { // 0 ('0000') to 15 ('1111')
      getCombos(arr, res, ctr)
    }
  }

  /**
   * Get the highest weighted bigram in the array.
   * @param {Array} arr - An array of bigram candidates.
   * @returns The heighest weighted bigram.
   */
  var calculateScores = function (arr) {
    let results = {}

    for (let i = 0; i < arr.length; i++) {
      let str = arr[i]
      let score = 0

      for (let j = 0; j < str.length - 1; j++) {
        if (isDigit(str[j])) {
          score += bigrams[replaceDigit(str[j]) + str[j + 1].toLowerCase()]
        } else if (isDigit(str[j + 1])) {
          score += bigrams[str[j].toLowerCase() + replaceDigit(str[j + 1])]
        } else {
          score += bigrams[str[j].toLowerCase() + str[j + 1].toLowerCase()]
        }
      }

      results[str] = score
    }

    return Object.keys(results).reduce(function (a, b) {
      if (results[a] > results[b]) {
        return a
      }

      return b
    })
  }

  const pseudoLetterblock = require('./lists/pseudoBigrams')
  const bigrams = pseudoLetterblock.bigrams
  const entropy = getEntropy()
  const letters = [
    ['1',  'A',  'J',  'a',  'h', 'px'],
    ['26', 'BC', 'LR', 'bc', 'i', 'r'],
    ['37', 'DH', 'N',  'd',  'j', 't'],
    ['48', 'E',  'PX', 'e',  'k', 'u'],
    ['59', 'FK', 'U',  'f',  'm', 'v'],
    ['0',  'QM', 'VW', 'gq', 'o', 'w']
  ]
  const delimiters = '.+-=@%'
  const blockEntropy = 4 * Math.floor(Math.log2(36))
  const totalEntropy = Math.ceil(entropy / blockEntropy) * blockEntropy
  const numBlocks = totalEntropy / blockEntropy
  const blocks = []
  const checks = []

  let pw = ''

  for (let i = 0; i < numBlocks; i++) {
    const jail = []
    const combos = []
    let block = ''
    let check = 0

    for (let j = 0; j < 4; j++) {
      const randNum = secRand(36, useEntropy)
      const row = Math.floor(randNum / 6)
      const col = randNum % 6

      let cell = letters[row][col]
      jail.push(cell)

      check += row + 1 // Indexed at 1 per the original proposal
    }

    getCombos(jail, combos, 0)

    let winner = calculateScores(combos)

    blocks.push(winner)
    checks.push(check)
  }

  for (let i = 0; i < blocks.length; i++) {
    pw += blocks[i]

    if (checks[i + 1] !== undefined) {
      pw += delimiters[(checks[i] + checks[i + 1]) % 6]
    }
  }

  return [pw, pw.length, totalEntropy]
}

/**
 * Generate a Munemo password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} An array containing the password, its length, and the entropy used.
 */
function generateMunemo(useEntropy) {
  // https://github.com/jmettraux/munemo
  /**
   * Recursive function to build an encoded string from a given number.
   * @param {number} num - The number to encode.
   * @param {string} str - The encoded string.
   * @returns {string} The encoded string.
   */
  var tos = function(num, str) {
    const munemo = [
      'ba',  'bi',  'bu',  'be',  'bo',  'cha', 'chi', 'chu', 'che', 'cho',
      'da',  'di',  'du',  'de',  'do',  'fa',  'fi',  'fu',  'fe',  'fo',
      'ga',  'gi',  'gu',  'ge',  'go',  'ha',  'hi',  'hu',  'he',  'ho',
      'ja',  'ji',  'ju',  'je',  'jo',  'ka',  'ki',  'ku',  'ke',  'ko',
      'la',  'li',  'lu',  'le',  'lo',  'ma',  'mi',  'mu',  'me',  'mo',
      'na',  'ni',  'nu',  'ne',  'no',  'pa',  'pi',  'pu',  'pe',  'po',
      'ra',  'ri',  'ru',  're',  'ro',  'sa',  'si',  'su',  'se',  'so',
      'sha', 'shi', 'shu', 'she', 'sho', 'ta',  'ti',  'tu',  'te',  'to',
      'tsa', 'tsi', 'tsu', 'tse', 'tso', 'wa',  'wi',  'wu',  'we',  'wo',
      'ya',  'yi',  'yu',  'ye',  'yo',  'za',  'zi',  'zu',  'ze',  'zo'
    ]

    let mod = num % 100n
    let rem = num / 100n
    str = munemo[mod] + str

    if (rem > 0) {
      return tos(rem, str)
    } else {
      return str
    }
  }

  const minEntropy = getEntropy()
  const isNegative = secRand(2, useEntropy)

  let num = 0n

  for (let i = 0; i < minEntropy - 1; i++) {
    // Half the key space is negative, half is non-negative
    num += BigInt(secRand(2, useEntropy) * 2 ** i)
  }

  let pass = tos(num, '')

  if (isNegative) {
    // 'xa' = -1 * num:
    //    fowohazehikorawihomeho =  1989259826396086294829
    //  xafowohazehikorawihomeho = -1989259826396086294829
    pass = 'xa' + pass
  }

  return [pass, pass.length, minEntropy]
}

/**
 * Generate a Proquints-compiant password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateProquints(useEntropy) {
  // https://arxiv.org/html/0901.4016
  const vowels = 'aiou'
  const consonants = 'bdfghjklmnprstvz'
  const entropy = getEntropy()
  const len = Math.ceil(entropy / 16)
  let pass = consonants[secRand(16, useEntropy)]

  for (let i = len; i > 0; i--) {
    pass += vowels[secRand(4, useEntropy)]
    pass += consonants[secRand(16, useEntropy)]
    pass += vowels[secRand(4, useEntropy)]

    if (i === 1) {
      break
    }

    pass += consonants[secRand(16, useEntropy)]
    pass += '-'
    pass += consonants[secRand(16, useEntropy)]
  }

  pass += consonants[secRand(16, useEntropy)]

  return [pass, pass.length, len * 16]
}

/**
 * Generate a Bubble Babble compliant password. Contains checksum.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateBabble(useEntropy) {
  // Spec: https://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt
  // Code based on https://github.com/kpalin/bubblepy
  const vowels = 'aeiouy'
  const consonants = 'bcdfghklmnprstvzx'
  const bytes = Math.ceil(getEntropy() / 8)
  const entropy = new Uint8Array(bytes)
  let pass = 'x'
  let checksum = 1

  for (let i = 0; i < entropy.length; i++) {
    entropy[i] = secRand(256, useEntropy)
  }

  for (let i = 0; i <= entropy.length; i += 2) {
    if (i >= entropy.length) {
      pass += vowels[checksum % 6] + consonants[16] + vowels[Math.floor(checksum / 6)]
      break
    }

    let byte1 = entropy[i]
    pass += vowels[(((byte1 >> 6) & 3) + checksum) % 6]
    pass += consonants[(byte1 >> 2) & 15]
    pass += vowels[((byte1 & 3) + Math.floor(checksum / 6)) % 6]

    if (i + 1 >= entropy.length) {
      break
    }

    let byte2 = entropy[i + 1]
    pass += consonants[(byte2 >> 4) & 15]
    pass += '-'
    pass += consonants[byte2 & 15]

    checksum = (checksum * 5 + byte1 * 7 + byte2) % 36
  }

  pass += 'x'

  return [pass, pass.length, entropy.length * 8]
}

/**
 * Generate a Daefen-compliant password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateDaefen(useEntropy) {
  const syllables = []
  const consonants = 'bcdfghjklmnprstvwz'
  const vowels = 'aeiouy'
  const entropy = getEntropy()

  let pass = ''

  // taken from https://github.com/alexvandesande/Daefen/blob/master/index.js
  // vowel + consonant
  for (let i = 0; i < vowels.length; i++) {
    for (let j = 0; j < consonants.length; j++) {
      syllables.push(vowels[i] + consonants[j])
    }
  }

  // consonant + vowel
  for (let i = 0; i < consonants.length; i++) {
    for (let j = 0; j < vowels.length; j++) {
      syllables.push(consonants[i] + vowels[j])
    }
  }

  // consonant + vowel + vowel
  for (let i = 0; i < consonants.length; i++) {
    for (let j = 0; j < vowels.length; j++) {
      for (let k = 0; k < vowels.length; k++) {
        syllables.push(consonants[i] + vowels[j] + vowels[k])
      }
    }
  }

  // consonant + vowel + consonant
  for (let i = 0; i < consonants.length; i++) {
    for (let j = 0; j < vowels.length; j++) {
      for (let k = 0; k < consonants.length; k++) {
        syllables.push(consonants[i] + vowels[j] + consonants[k])
      }
    }
  }

  // vowel + consonant + vowel
  for (let i = 0; i < vowels.length; i++) {
    for (let j = 0; j < consonants.length; j++) {
      for (let k = 0; k < vowels.length; k++) {
        syllables.push(vowels[i] + consonants[j] + vowels[k])
      }
    }
  }

  const len = Math.ceil(entropy / Math.log2(syllables.length)) // 16 bits per "word"

  /**
   * Determine if the letter is a consonant.
   * @param {string} letter - A letter to be added to the password.
   * @returns True if the letter is a consonant, false if it is a vowel.
   */
  var isConsonant = function (letter) {
    return consonants.indexOf(letter) >= 0
  }

  for (let i = 0; i < len; i ++) {
    let n = secRand(syllables.length, useEntropy)
    let lastWord = pass.split('-').slice(-1)[0]

    if (
      pass === '' || lastWord.length === syllables[n].length ||
      (
        lastWord.length < 5 &&
        isConsonant(lastWord.slice(-1)) &&
        isConsonant(syllables[n].slice(0, 1))
      )) {
      pass += syllables[n]
    } else {
      pass += '-' + syllables[n]
    }
  }

  pass = pass.replace(/\b[a-z]/g, function(f) {
    return f.toUpperCase()
  })

  return [pass, pass.length, Math.floor(len * Math.log2(syllables.length))]
}

/**
 * Generate an urbit phonetic password.
 * @param {boolean} useEntropy - Whether or not to use the data in the entropy file.
 * @returns {Array} The password string, the length of the password, and the entropy of the password.
 */
function generateUrbit(useEntropy) {
  const prefixes = [
    "doz", "mar", "bin", "wan", "sam", "lit", "sig", "hid", "fid", "lis", "sog", "dir", "wac", "sab", "wis", "sib",
    "rig", "sol", "dop", "mod", "fog", "lid", "hop", "dar", "dor", "lor", "hod", "fol", "rin", "tog", "sil", "mir",
    "hol", "pas", "lac", "rov", "liv", "dal", "sat", "lib", "tab", "han", "tic", "pid", "tor", "bol", "fos", "dot",
    "los", "dil", "for", "pil", "ram", "tir", "win", "tad", "bic", "dif", "roc", "wid", "bis", "das", "mid", "lop",
    "ril", "nar", "dap", "mol", "san", "loc", "nov", "sit", "nid", "tip", "sic", "rop", "wit", "nat", "pan", "min",
    "rit", "pod", "mot", "tam", "tol", "sav", "pos", "nap", "nop", "som", "fin", "fon", "ban", "mor", "wor", "sip",
    "ron", "nor", "bot", "wic", "soc", "wat", "dol", "mag", "pic", "dav", "bid", "bal", "tim", "tas", "mal", "lig",
    "siv", "tag", "pad", "sal", "div", "dac", "tan", "sid", "fab", "tar", "mon", "ran", "nis", "wol", "mis", "pal",
    "las", "dis", "map", "rab", "tob", "rol", "lat", "lon", "nod", "nav", "fig", "nom", "nib", "pag", "sop", "ral",
    "bil", "had", "doc", "rid", "moc", "pac", "rav", "rip", "fal", "tod", "til", "tin", "hap", "mic", "fan", "pat",
    "tac", "lab", "mog", "sim", "son", "pin", "lom", "ric", "tap", "fir", "has", "bos", "bat", "poc", "hac", "tid",
    "hav", "sap", "lin", "dib", "hos", "dab", "bit", "bar", "rac", "par", "lod", "dos", "bor", "toc", "hil", "mac",
    "tom", "dig", "fil", "fas", "mit", "hob", "har", "mig", "hin", "rad", "mas", "hal", "rag", "lag", "fad", "top",
    "mop", "hab", "nil", "nos", "mil", "fop", "fam", "dat", "nol", "din", "hat", "nac", "ris", "fot", "rib", "hoc",
    "nim", "lar", "fit", "wal", "rap", "sar", "nal", "mos", "lan", "don", "dan", "lad", "dov", "riv", "bac", "pol",
    "lap", "tal", "pit", "nam", "bon", "ros", "ton", "fod", "pon", "sov", "noc", "sor", "lav", "mat", "mip", "fip"]
  const suffixes = [
    "zod", "nec", "bud", "wes", "sev", "per", "sut", "let", "ful", "pen", "syt", "dur", "wep", "ser", "wyl", "sun",
    "ryp", "syx", "dyr", "nup", "heb", "peg", "lup", "dep", "dys", "put", "lug", "hec", "ryt", "tyv", "syd", "nex",
    "lun", "mep", "lut", "sep", "pes", "del", "sul", "ped", "tem", "led", "tul", "met", "wen", "byn", "hex", "feb",
    "pyl", "dul", "het", "mev", "rut", "tyl", "wyd", "tep", "bes", "dex", "sef", "wyc", "bur", "der", "nep", "pur",
    "rys", "reb", "den", "nut", "sub", "pet", "rul", "syn", "reg", "tyd", "sup", "sem", "wyn", "rec", "meg", "net",
    "sec", "mul", "nym", "tev", "web", "sum", "mut", "nyx", "rex", "teb", "fus", "hep", "ben", "mus", "wyx", "sym",
    "sel", "ruc", "dec", "wex", "syr", "wet", "dyl", "myn", "mes", "det", "bet", "bel", "tux", "tug", "myr", "pel",
    "syp", "ter", "meb", "set", "dut", "deg", "tex", "sur", "fel", "tud", "nux", "rux", "ren", "wyt", "nub", "med",
    "lyt", "dus", "neb", "rum", "tyn", "seg", "lyx", "pun", "res", "red", "fun", "rev", "ref", "mec", "ted", "rus",
    "bex", "leb", "dux", "ryn", "num", "pyx", "ryg", "ryx", "fep", "tyr", "tus", "tyc", "leg", "nem", "fer", "mer",
    "ten", "lus", "nus", "syl", "tec", "mex", "pub", "rym", "tuc", "fyl", "lep", "deb", "ber", "mug", "hut", "tun",
    "byl", "sud", "pem", "dev", "lur", "def", "bus", "bep", "run", "mel", "pex", "dyt", "byt", "typ", "lev", "myl",
    "wed", "duc", "fur", "fex", "nul", "luc", "len", "ner", "lex", "rup", "ned", "lec", "ryd", "lyd", "fen", "wel",
    "nyd", "hus", "rel", "rud", "nes", "hes", "fet", "des", "ret", "dun", "ler", "nyr", "seb", "hul", "ryl", "lud",
    "rem", "lys", "fyn", "wer", "ryc", "sug", "nys", "nyl", "lyn", "dyn", "dem", "lux", "fed", "sed", "bec", "mun",
    "lyr", "tes", "mud", "nyt", "byr", "sen", "weg", "fyr", "mur", "tel", "rep", "teg", "pec", "nel", "nev", "fes"]
  const entropy = getEntropy()
  const len = Math.ceil(entropy / 16) // 16 bits per "word"

  let pass = '~'

  for (let i = len; i > 0; i--) {
    pass += prefixes[secRand(256, useEntropy)] + suffixes[secRand(256, useEntropy)]

    if (i > 1) {
      pass += '-'
    }
  }

  return [pass, pass.length, len * 16]
}

/**
 * Generate a pseudowords password.
 * @param {boolean} useEntropy - Whether or not to use the entropy in the data file.
 * @returns {Object} An associative array of the generated password and its meta.
 */
function generatePseudowords(useEntropy) {
  let checksum = false
  let pseudoSet
  let ret

  if (ARGS.includes('-p') || ARGS.includes('--pseudowords')) {
    const option = ARGS.findIndex((option) => option === '-p' || option === '--pseudowords')
    pseudoSet = ARGS[option + 1]
  } else {
    pseudoSet = 'Apple'
  }

  if (pseudoSet.toLowerCase() === 'apple') {
    ret = generateApple(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'babble') {
    checksum = true
    ret = generateBabble(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'daefen') {
    ret = generateDaefen(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'letterblock') {
    checksum = true
    ret = generateLetterblock(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'munemo') {
    ret = generateMunemo(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'proquints') {
    ret = generateProquints(useEntropy)
  } else if (pseudoSet.toLowerCase() === 'urbit') {
    ret = generateUrbit(useEntropy)
  } else {
    console.log('Unknown generator:', pseudoSet)
    process.exit(1)
  }

  const assocArr = {}
  const pass = ret[0]
  const len = ret[1]
  const ent = ret[2]

  assocArr.Generator = 'Pseudowords'
  assocArr.Wordlist = pseudoSet
  assocArr.Password = pass
  assocArr.Characters = len
  assocArr.Entropy = ent

  if (checksum) {
    assocArr.Checksum = true
  }

  return assocArr
}

/**
 * Generate a random meaningless password string.
 * @param {number} b - A number base.
 * @param {boolean} useEntropy - Whether or not to use the entropy in the data file.
 * @returns {Object} An associative array of the generated password and its meta.
 */
function generateSet(b, useEntropy) {
  const entropy = getEntropy()
  const assocArr = {}
  let checksum = false
  let ident = ''
  let s = ''

  if (b == 256) {
    s = 'á¸€á¸á¸‚á¸ƒá¸„á¸…á¸†á¸‡á¸ˆá¸‰á¸Šá¸‹á¸Œá¸á¸Žá¸á¸á¸‘á¸’á¸“á¸”á¸•á¸–á¸—á¸˜á¸™á¸šá¸›á¸œá¸á¸žá¸Ÿá¸ á¸¡á¸¢á¸£á¸¤á¸¥á¸¦á¸§á¸¨á¸©á¸ªá¸«á¸¬á¸­á¸®á¸¯á¸°á¸±á¸²á¸³á¸´á¸µá¸¶á¸·á¸¸á¸¹á¸ºá¸»á¸¼á¸½á¸¾á¸¿'
    s += 'á¹€á¹á¹‚á¹ƒá¹„á¹…á¹†á¹‡á¹ˆá¹‰á¹Šá¹‹á¹Œá¹á¹Žá¹á¹á¹‘á¹’á¹“á¹”á¹•á¹–á¹—á¹˜á¹™á¹šá¹›á¹œá¹á¹žá¹Ÿá¹ á¹¡á¹¢á¹£á¹¤á¹¥á¹¦á¹§á¹¨á¹©á¹ªá¹«á¹¬á¹­á¹®á¹¯á¹°á¹±á¹²á¹³á¹´á¹µá¹¶á¹·á¹¸á¹¹á¹ºá¹»á¹¼á¹½á¹¾á¹¿'
    s += 'áº€áºáº‚áºƒáº„áº…áº†áº‡áºˆáº‰áºŠáº‹áºŒáºáºŽáºáºáº‘áº’áº“áº”áº•áº–áº—áº˜áº™áºšáº›áºœáºáºžáºŸáº áº¡áº¢áº£áº¤áº¥áº¦áº§áº¨áº©áºªáº«áº¬áº­áº®áº¯áº°áº±áº²áº³áº´áºµáº¶áº·áº¸áº¹áººáº»áº¼áº½áº¾áº¿'
    s += 'á»€á»á»‚á»ƒá»„á»…á»†á»‡á»ˆá»‰á»Šá»‹á»Œá»á»Žá»á»á»‘á»’á»“á»”á»•á»–á»—á»˜á»™á»šá»›á»œá»á»žá»Ÿá» á»¡á»¢á»£á»¤á»¥á»¦á»§á»¨á»©á»ªá»«á»¬á»­á»®á»¯á»°á»±á»²á»³á»´á»µá»¶á»·á»¸á»¹á»ºá»»á»¼á»½á»¾á»¿'
    ident = 'Latin Extended'
  } else if (b === 220) {
    for (let i = 0; i < 94; i++) {
      // Standard ASCII
      s += String.fromCharCode(33 + i)
    }
    // Excludes Unicode U+F8FF in the Corporate Private Use Area for the Apple logo
    s += 'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºÎ©Ã¦'
    s += 'Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„â‚¬â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡'
    ident = 'Mac OS Roman'
  } else if (b === 188) {
    for (let i = 0; i < 94; i++) {
      s += String.fromCharCode(33 + i)
    }
    for (let i = 0; i < 95; i++) {
      s += String.fromCharCode(161 + i)
    }
    s = s.replace(String.fromCharCode(173), '') // soft-hyphen isn't graphical
    ident = 'ISO 8859-1'
  } else if (b === 94) {
    for (let i = 0; i < 94; i++) {
      s += String.fromCharCode(33 + i)
    }
    ident = 'Base94'
  } else if (b === 85) {
    s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&()*+-;<=>?@^_`{|}~'
    ident = 'Base85'
  } else if (b === 64) {
    s = '`!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'
    ident = 'Base64'
  } else if (b === 62) {
    s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    ident = 'Base62'
  } else if (b === 58) {
    s = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    ident = 'Base58'
  } else if (b === 52) {
    s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    ident = 'Base52'
  } else if (b === 45) {
    s = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_$%*+-./:'
    ident = 'Base45'
  } else if (b === 36) {
    s = '0123456789abcdefghijklmnopqrstuvwxyz'
    ident = 'Base36'
  } else if (b === 32) {
    s = '0123456789abcdefghjkmnpqrstvwxyz'
    ident = 'Base32'
    checksum = true
  } else if (b === 26) {
    s = 'abcdefghjkmnpqrstvwxyz'
    ident = 'Base26'
  } else if (b === 16) {
    s = '0123456789abcdef'
    ident = 'Base16'
  } else if (b === 10) {
    s = '0123456789'
    ident = 'Base10'
  } else if (b === 8) {
    s = '01234567'
    ident = 'Base8'
  } else if (b === 4) {
    s = 'ACGT'
    ident = 'Base4'
  } else if (b === 2) {
    s = '01'
    ident = 'Base2'
  }

  const len = Math.ceil(entropy / Math.log2(s.length))
  let pass = generatePass(len, s, false, useEntropy)

  if (b === 32) {
    // Add Crockford's modulo 37 checksum
    let res = 0n
    const check = s + '*~$=u'

    for (let i = 0; i < pass.length; i++) {
      res += BigInt(s.indexOf(pass[i]) * 32 ** (pass.length - i - 1))
    }

    pass += check[res % 37n]
  }

  assocArr.Generator = 'Random'
  assocArr.Wordlist = ident
  assocArr.Password = pass
  assocArr.Characters = len
  assocArr.Entropy = Math.floor(len * Math.log2(s.length))

  if (checksum) {
    assocArr.Checksum = true
  }

  return assocArr
}

/**
 * Determine the right password generator to use when generating the random password.
 * @param {boolean} useEntropy - Whether or not to use the entropy in the data file.
 * @returns {Object} An associative array of the generated password and its meta from the correctly determined helper function.
 */
function generateRandom(useEntropy) {
  let assocArr
  let randSet

  if (ARGS.includes('-r') || ARGS.includes('--random')) {
    const option = ARGS.findIndex((option) => option === '-r' || option === '--random')
    randSet = ARGS[option + 1]
  } else {
    randSet = 'Base94'
  }

  if (randSet.toLowerCase() === 'base256') {
    assocArr = generateSet(256, useEntropy)
  } else if (randSet.toLowerCase() === 'base220') {
    assocArr = generateSet(220, useEntropy)
  } else if (randSet.toLowerCase() === 'base188') {
    assocArr = generateSet(188, useEntropy)
  } else if (randSet.toLowerCase() === 'base94') {
    assocArr = generateSet(94, useEntropy)
  } else if (randSet.toLowerCase() === 'base85') {
    assocArr = generateSet(85, useEntropy)
  } else if (randSet.toLowerCase() === 'base64') {
    assocArr = generateSet(64, useEntropy)
  } else if (randSet.toLowerCase() === 'base62') {
    assocArr = generateSet(62, useEntropy)
  } else if (randSet.toLowerCase() === 'base58') {
    assocArr = generateSet(58, useEntropy)
  } else if (randSet.toLowerCase() === 'base52') {
    assocArr = generateSet(52, useEntropy)
  } else if (randSet.toLowerCase() === 'base45') {
    assocArr = generateSet(45, useEntropy)
  } else if (randSet.toLowerCase() === 'base36') {
    assocArr = generateSet(36, useEntropy)
  } else if (randSet.toLowerCase() === 'base32') {
    assocArr = generateSet(32, useEntropy)
  } else if (randSet.toLowerCase() === 'base26') {
    assocArr = generateSet(26, useEntropy)
  } else if (randSet.toLowerCase() === 'base16') {
    assocArr = generateSet(16, useEntropy)
  } else if (randSet.toLowerCase() === 'base10') {
    assocArr = generateSet(10, useEntropy)
  } else if (randSet.toLowerCase() === 'base8') {
    assocArr = generateSet(8, useEntropy)
  } else if (randSet.toLowerCase() === 'base4') {
    assocArr = generateSet(4, useEntropy)
  } else if (randSet.toLowerCase() === 'base2') {
    assocArr = generateSet(2, useEntropy)
  } else if (randSet.toLowerCase() === 'emoji') {
    assocArr = generateEmoji(useEntropy)
  } else {
    console.log('Unknown set:', randSet)
    process.exit(1)
  }

  return assocArr
}

/**
 * Generate an emoji password.
 * @param {boolean} useEntropy - Whether or not to use the entropy in the data file.
 * @returns {Object} An associative array of the generated password and its meta.
 */
function generateEmoji(useEntropy) {
  const emojiWordlist = require('./lists/random_emoji')
  const wordlist = uniquesOnly(emojiWordlist.wordlist)
  const entropy = getEntropy()
  const assocArr = {}
  const len = Math.ceil(entropy / Math.log2(wordlist.length))

  let pass = generatePass(len, wordlist, true, useEntropy)

  pass = pass.replace(/ /g, '')
  assocArr.Generator = 'Random'
  assocArr.Wordlist = 'Emoji'
  assocArr.Password = pass
  assocArr.Characters = len
  assocArr.Entropy = Math.floor(len * Math.log2(wordlist.length))

  return assocArr
}

/**
 * Shuffle an array using the Fisher-Yates shuffle with a CSPRNG.
 * @param {Array} array - An array to shuffle the contents of.
 * @returns {Array} The shuffled array.
 */
function shuffle(array) {
  let counter = array.length

  while (counter > 0) {
    let index = secRand(counter, false)
    counter--

    let temp = array[counter]
    array[counter] = array[index]
    array[index] = temp
  }

  return array
}

/**
 * Debias the bitstring using the John von Neumann debias algorithm.
 * @param {number} bits - The bits that need dibasing.
 * @returns {number} The debiased bits.
 */
function debias(bits) {
  let bitstr = ''

  for (let i = 0; i < 8; i++) {
    let pair = (bits >> BigInt(14 - 2 * i)) & 0x3n

    if (pair === 1n || pair === 2n) {
      bitstr += pair >> 1n
    }
  }

  return bitstr
}

/**
 * Collect and debias raw entropy from the keyboard.
 * @param {Array} arr - An array containing raw data that needs to be debiased.
 * @returns {string} The debiased data.
 */
function processEntropy(arr) {
  let unbiasedBitstr = ''

  for (let i = 0; i < arr.length; i++) {
    unbiasedBitstr += debias(arr[i])
  }

  return unbiasedBitstr
}

/**
 * Collect raw keyboard timing input from the user. Generate some helper text for the user to type from the Scripps National Spelling Bee word list.
 * @param {Object} entropyFile - The file containing the entropy data.
 */
function collectInput(entropyFile) {
  const readline = require('readline')
  const alternateScripps = require('./lists/alternateScripps')
  const wordlist = alternateScripps.wordlist

  let input = ''
  let words = ''
  let lastKey = ''
  let lastKeyTime = 0
  const ns = []
  const challenge = shuffle(wordlist)

  for (let i = 0; i < 100; i++) {
    words += challenge[i]
    words += ' '
  }

  console.log(
    `
    Type, not paste these 100 words. Be as accurate as possible, but don't stress it.
    Entropy is calculated on keypress timings, not the content itself.
    Entropy is saved in ` +
      entropyFile +
      `. Type <ctrl>-<c> when finished.`
  )
  console.log()
  console.log(words)
  console.log()

  readline.emitKeypressEvents(process.stdin)
  process.stdin.setRawMode(true)

  process.stdin.on('keypress', (str, key) => {
    /*
      Preventing long-press key repeats, forcing users to type individual keys. I want the user's
      neural chaotic entropy, not the system's interrupt requests.

      The fastest typists in the world regularly clock in above 200 wpm. If an English word
      averages 5 characters, that's 1,000 characters per minute, or about 17 characters per second.
      At 17 characters per second, that's a 60 ms delay between key presses on average.

      The average English typist however is approximately 40 words or 200 characters per minute.
      That's about 3 characters per second, or about 300 ms delay between key presses.

      Quick table:

      |  wpm  |  cpm  |  cps  | Delay  |
      | :---: | :---: | :---: | :----: |
      |   40  |  200  |  3.33 | 300 ms | <- average typist
      |   60  |  300  |   5   | 200 ms |
      |   80  |  400  |  6.66 | 150 ms |
      |  100  |  500  |  8.33 | 120 ms | <- my personal typing average
      |  120  |  600  |   10  | 100 ms |
      |  140  |  700  | 11.66 |  86 ms |
      |  160  |  800  | 13.33 |  75 ms |
      |  180  |  900  |   15  |  67 ms |
      |  200  | 1000  | 16.66 |  60 ms |
      |  220  | 1100  | 18.33 |  55 ms | <- current typing speed records
      |  240  | 1200  |   20  |  50 ms |

      The "Big Three" operating systems all have 30 ms default key repeat delays:

        * Windows: 250 ms initial delay, 30 ms repeat
        * Mac: 225 ms initial delay, 30 ms repeat
        * Linux (GNOME): 500 ms initial delay, 30 ms repeat

      I couldn't figure out if NodeJS had an API for catching and disabling key repeats, so I asked
      for help: https://stackoverflow.com/q/68369655/868868. NodeJS really should have a boolean to
      toggle for catching keypress repeats.

      Typing at 200 wpm or faster is unlikely given current typing records, and 60 ms still will
      catch operating system key press repeats.
    */
    if (lastKey == key.sequence && new Date().getTime() - lastKeyTime < 60) {
      lastKeyTime = new Date().getTime()
      return
    }

    process.stdout.write(str)
    ns.push(process.hrtime.bigint() & 0xffffn) // least significant 16-bits (65536 nanoseconds)

    lastKey = key.sequence
    lastKeyTime = new Date().getTime()

    if (key.name === 'return') {
      process.stdout.write('\n')
    }

    if (key.ctrl && key.name === 'c') {
      let entropy
      let bitstr = processEntropy(ns)

      try {
        entropy = JSON.parse(FS.readFileSync(entropyFile, 'utf8'))
      } catch (err) {
        entropy = []
      }

      const div = Math.floor(bitstr.length / 16)

      for (let i = 0; i < div; i++) {
        entropy.push(parseInt(bitstr.substr(16 * i, 16), 2))
      }

      try {
        FS.writeFileSync(entropyFile, JSON.stringify(entropy))
      } catch (err) {
        console.error(err)
      }

      process.exit(0)
    }
  })
}

/** The main function. Handles program options. */
function main() {
  let generator
  let useEntropy = false
  const results = []
  const entropyFile = setEntropyFile()

  // Start processing the command line options
  if (ARGS.includes('-h') || ARGS.includes('--help')) {
    // print usage
    printUsage()
  }

  if (ARGS.includes('-o') || ARGS.includes('--only')) {
    // only one specific generator
    const option = ARGS.findIndex((option) => option === '-o' || option === '--only')
    generator = ARGS[option + 1]

    if (ARGS.includes('-u') || ARGS.includes('--use-entropy')) {
      // use keyboard entropy
      useEntropy = true
    }
  } else if (ARGS.includes('-u') || ARGS.includes('--use-entropy')) {
    // require -o, --only however
    console.error('You must use `-o, --only GENERATOR` with `-u, --use-entropy`.')
    process.exit(1)
  }

  if (ARGS.includes('-k') || ARGS.includes('--keyboard')) {
    // collect keyboard entropy, not generate passwords
    collectInput(entropyFile)
  } else if (ARGS.includes('-s') || ARGS.includes('--stats')) {
    // report keyboard entropy stats, not generate passwords
    try {
      const entropy = JSON.parse(FS.readFileSync(entropyFile, 'utf8')).length

      console.log(
        'You have ' + entropy + ' samples (' + entropy * 16 + ' bits) of entropy available.'
      )
    } catch (err) {
      console.log(
        'You have not collected any keyboard entropy. Collect some with `-k, --keyboard`.'
      )
    }
  } else if (generator !== undefined && generator !== null) {
    // otherwise generate passwords from a specific generator
    if (generator.toLowerCase() === 'alternate') {
      results.push(generateAlternate(useEntropy))
    } else if (generator.toLowerCase() === 'bitcoin') {
      results.push(generateBitcoin(useEntropy))
    } else if (generator.toLowerCase() === 'monero') {
      results.push(generateMonero(useEntropy))
    } else if (generator.toLowerCase() === 'diceware') {
      results.push(generateDiceware(useEntropy))
    } else if (generator.toLowerCase() === 'eff') {
      results.push(generateEff(useEntropy))
    } else if (generator.toLowerCase() === 'pseudowords') {
      results.push(generatePseudowords(useEntropy))
    } else if (generator.toLowerCase() === 'random') {
      results.push(generateRandom(useEntropy))
    } else {
      const option = ARGS.findIndex((option) => option === '-o' || option === '--only')
      console.log('Unknown generator:', ARGS[option + 1])
      process.exit(1)
    }
  } else {
    // otherwise generate all the passwords
    results.push(generateAlternate(useEntropy))
    if (ARGS.includes('-M') || ARGS.includes('--monero')) {
        results.push(generateMonero(useEntropy))
    } else {
        results.push(generateBitcoin(useEntropy))
    }
    results.push(generateDiceware(useEntropy))
    results.push(generateEff(useEntropy))
    results.push(generatePseudowords(useEntropy))
    results.push(generateRandom(useEntropy))
  }

  if (ARGS.includes('-j') || ARGS.includes('--json')) {
    // output valid json
    console.log(JSON.stringify(results))
  } else {
    for (let i = 0; i < results.length; i++) {
      console.log(results[i].Generator + '(' + results[i].Wordlist + '): ' + results[i].Password)
    }
  }
}

main()
